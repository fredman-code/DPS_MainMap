import React, { useState, useEffect } from 'react';
import { 
  View, 
  Image, 
  Dimensions, 
  StyleSheet, 
  Text, 
  TouchableOpacity,
  Alert
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import Svg, { Line } from 'react-native-svg';
import { collection, getDocs } from 'firebase/firestore';
import db from '../firebaseConfig'; // Must be a valid Firestore instance (e.g., getFirestore(app))
import { adjustedMaps } from './data';

// =================================================
// 1. Extract Senior FF Map Data
// =================================================
const seniorFF = adjustedMaps.find(map => map.name === "Senior FF");
if (!seniorFF) {
  throw new Error("Senior FF map not found in adjustedMaps");
}

const mapData = {
  name: seniorFF.name,
  image: seniorFF.image,
  originalWidth: seniorFF.originalWidth,
  originalHeight: seniorFF.originalHeight,
};

// =================================================
// 2. Define New Turning Points for Senior FF
// =================================================
const roadPoints: number[][] = [
  [992,606],[2211,597],[1000,970],[230,1606],[676,1601],[290,597],[2218,478],[2261,434]
];

// =================================================
// 3. Derive Classrooms from Corridors in Senior FF
// =================================================
const classrooms = seniorFF.corridors.reduce<{ id: number; coords: number[]; name: string }[]>((acc, corridor) => {
  corridor.rooms.forEach(roomNumber => {
    const point = seniorFF.points[roomNumber - 1];
    if (point) {
      acc.push({
        id: roomNumber,
        coords: point,
        name: `Class ${roomNumber}`,
      });
    }
  });
  return acc;
}, []);

// =================================================
// 4. Setup Scaling to Maintain Aspect Ratio
// =================================================
const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;
const widthRatio = screenWidth / mapData.originalWidth;
const heightRatio = screenHeight / mapData.originalHeight;
const baseScale = Math.min(widthRatio, heightRatio);

const normalize = ([x, y]: number[]): { x: number; y: number } => ({
  x: x * baseScale,
  y: y * baseScale,
});

const normalizedRoadPoints = roadPoints.map(normalize);
const normalizedClassrooms = classrooms.map(({ id, coords, name }) => ({
  id,
  name,
  coords: normalize(coords),
}));

// =================================================
// 5. Define Road Connections (1-indexed) and Convert to 0-indexed
// Provided connections: (6,1), (1,3), (4,5), (1,2), (2,7), (7,8)
const roadConnections = new Map<number, number[]>([
  [1, [6, 3, 2]],  // 1 connects to 6, 3, and 2
  [2, [1, 7]],     // 2 connects to 1 and 7
  [3, [1]],        // 3 connects to 1
  [4, [5]],        // 4 connects to 5
  [5, [4]],        // 5 connects to 4
  [6, [1]],        // 6 connects to 1
  [7, [2, 8]],     // 7 connects to 2 and 8
  [8, [7]],        // 8 connects to 7
]);
const roadConnections0 = new Map<number, number[]>();
roadConnections.forEach((neighbors, key) => {
  roadConnections0.set(key - 1, neighbors.map(n => n - 1));
});

// =================================================
// 6. Define Building Areas from an HTML image map
// =================================================
type BuildingArea = 
  | { id: number; shape: 'poly'; coords: { x: number; y: number }[] }
  | { id: number; shape: 'rect'; coords: { left: number; top: number; right: number; bottom: number } };

const buildingAreas: BuildingArea[] = [
  {
    id: 1,
    shape: 'poly',
    coords: [
      { x: 438, y: 430 },
      { x: 2353, y: 83 },
      { x: 2342, y: 816 },
      { x: 2350, y: 1718 },
      { x: 1713, y: 1694 },
      { x: 874,  y: 1643 },
      { x: 867,  y: 1088 },
      { x: 986,  y: 1088 },
      { x: 399,  y: 1119 },
    ],
  },
  {
    id: 2,
    shape: 'rect',
    coords: { left: 13, top: 1361, right: 846, bottom: 1752 },
  },
  {
    id: 3,
    shape: 'rect',
    coords: { left: 122, top: 479, right: 415, bottom: 758 },
  },
];

const scaleBuildingArea = (area: BuildingArea): BuildingArea => {
  if (area.shape === 'poly') {
    return {
      ...area,
      coords: area.coords.map(pt => ({ x: pt.x * baseScale, y: pt.y * baseScale })),
    };
  } else {
    return {
      ...area,
      coords: {
        left: area.coords.left * baseScale,
        top: area.coords.top * baseScale,
        right: area.coords.right * baseScale,
        bottom: area.coords.bottom * baseScale,
      },
    };
  }
};

const scaledBuildingAreas = buildingAreas.map(scaleBuildingArea);

const pointInPolygon = (point: { x: number; y: number }, polygon: { x: number; y: number }[]): boolean => {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x, yi = polygon[i].y;
    const xj = polygon[j].x, yj = polygon[j].y;
    const intersect = ((yi > point.y) !== (yj > point.y)) &&
      (point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
};

const pointInRect = (point: { x: number; y: number }, rect: { left: number; top: number; right: number; bottom: number }): boolean => {
  return point.x >= rect.left && point.x <= rect.right &&
         point.y >= rect.top && point.y <= rect.bottom;
};

const getBuildingForPoint = (point: { x: number; y: number }): number | null => {
  for (const area of scaledBuildingAreas) {
    if (area.shape === 'poly') {
      if (pointInPolygon(point, area.coords)) return area.id;
    } else {
      if (pointInRect(point, area.coords)) return area.id;
    }
  }
  return null;
};

// =================================================
// 7. Utility Functions (BFS)
// =================================================
const getClosestPointIndex = (classroomCoords: { x: number; y: number }): number => {
  let closestIndex = 0;
  let minDistance = Infinity;
  normalizedRoadPoints.forEach((point, index) => {
    const distance = Math.sqrt(
      (point.x - classroomCoords.x) ** 2 + (point.y - classroomCoords.y) ** 2
    );
    if (distance < minDistance) {
      minDistance = distance;
      closestIndex = index;
    }
  });
  return closestIndex;
};

const findValidPath = (start: number, end: number): number[] => {
  let queue: number[][] = [[start]];
  let visited = new Set<number>();

  while (queue.length > 0) {
    const path = queue.shift();
    if (!path) continue;
    const lastNode = path[path.length - 1];
    if (lastNode === end) return path;

    if (!visited.has(lastNode)) {
      visited.add(lastNode);
      const neighbors = roadConnections0.get(lastNode);
      if (neighbors) {
        for (const neighbor of neighbors) {
          if (!visited.has(neighbor)) {
            queue.push([...path, neighbor]);
          }
        }
      }
    }
  }
  return [];
};

// =================================================
// 8. SeniorFFOverlay Component
// =================================================
const SeniorFFOverlay: React.FC = () => {
  const [selectedClass1, setSelectedClass1] = useState<number | null>(null);
  const [selectedClass2, setSelectedClass2] = useState<number | null>(null);
  const [selectedPath, setSelectedPath] = useState<number[]>([]);
  const [classroomNames, setClassroomNames] = useState<Record<number, string>>({});
  const [loading, setLoading] = useState<boolean>(true);

  // Fetch classroom names from Firestore (collection "Senior FF")
  useEffect(() => {
    const fetchClassroomNames = async () => {
      try {
        setLoading(true);
        const snapshot = await getDocs(collection(db, mapData.name));
        const names: Record<number, string> = {};
        snapshot.forEach(doc => {
          const docId = parseInt(doc.id, 10);
          const data = doc.data();
          const fieldNames = Object.keys(data);
          if (fieldNames.length > 0) {
            names[docId] = fieldNames[0]; // e.g., "KG 1 - A"
          }
        });
        setClassroomNames(names);
      } catch (error) {
        console.error("Error fetching classroom names: ", error);
      } finally {
        setLoading(false);
      }
    };
    fetchClassroomNames();
  }, [mapData.name]);

  const handleSelection = () => {
    if (selectedClass1 !== null && selectedClass2 !== null) {
      const cp1 = getClosestPointIndex(normalizedClassrooms[selectedClass1].coords);
      const cp2 = getClosestPointIndex(normalizedClassrooms[selectedClass2].coords);

      // Determine which building each selected classroom is in.
      const building1 = getBuildingForPoint(normalizedClassrooms[selectedClass1].coords);
      const building2 = getBuildingForPoint(normalizedClassrooms[selectedClass2].coords);

      if (building1 === null || building2 === null) {
        Alert.alert("Warning", "One of the selected classrooms is not within a defined building.");
        return;
      }
      if (building1 !== building2) {
        Alert.alert("Warning", "Selected classrooms are in different buildings and cannot be connected.");
        return;
      }

      // Compute the valid path (only after Confirm Selection is clicked)
      const validPath = findValidPath(cp1, cp2);
      if (validPath.length === 0) {
        Alert.alert("Warning", "These two classes cannot be reached.");
      } else {
        setSelectedPath(validPath);
      }
    }
  };

  return (
    <View style={styles.container}>
      {/* Background Image */}
      <Image
        source={mapData.image}
        style={{
          width: mapData.originalWidth * baseScale,
          height: mapData.originalHeight * baseScale,
        }}
        resizeMode="contain"
      />

      {/* SVG Overlay for drawing paths */}
      <Svg
        width={mapData.originalWidth * baseScale}
        height={mapData.originalHeight * baseScale}
        style={styles.svgOverlay}
        pointerEvents="none"
      >
        {selectedPath.map((pointIndex, i) => {
          if (i === selectedPath.length - 1) return null;
          const nextPointIndex = selectedPath[i + 1];
          return (
            <Line
              key={i}
              x1={normalizedRoadPoints[pointIndex]?.x}
              y1={normalizedRoadPoints[pointIndex]?.y}
              x2={normalizedRoadPoints[nextPointIndex]?.x}
              y2={normalizedRoadPoints[nextPointIndex]?.y}
              stroke="#333"
              strokeWidth={2}
            />
          );
        })}
        {selectedClass1 !== null && selectedPath.length > 0 && (
          <Line
            x1={normalizedClassrooms[selectedClass1].coords.x}
            y1={normalizedClassrooms[selectedClass1].coords.y}
            x2={normalizedRoadPoints[selectedPath[0]]?.x}
            y2={normalizedRoadPoints[selectedPath[0]]?.y}
            stroke="#333"
            strokeWidth={2}
          />
        )}
        {selectedClass2 !== null && selectedPath.length > 0 && (
          <Line
            x1={normalizedClassrooms[selectedClass2].coords.x}
            y1={normalizedClassrooms[selectedClass2].coords.y}
            x2={normalizedRoadPoints[selectedPath[selectedPath.length - 1]]?.x}
            y2={normalizedRoadPoints[selectedPath[selectedPath.length - 1]]?.y}
            stroke="#333"
            strokeWidth={2}
          />
        )}
      </Svg>

      {/* Dropdowns for Classroom Selection */}
      <View style={styles.dropdownContainer}>
        <Picker
          selectedValue={selectedClass1}
          onValueChange={(itemValue) => setSelectedClass1(itemValue)}
          style={styles.picker}
        >
          <Picker.Item label="Select Classroom 1" value={null} />
          {normalizedClassrooms.map((classroom, idx) => (
            <Picker.Item
              key={classroom.id}
              label={classroomNames[classroom.id] || classroom.name}
              value={idx}
            />
          ))}
        </Picker>
        <Picker
          selectedValue={selectedClass2}
          onValueChange={(itemValue) => setSelectedClass2(itemValue)}
          style={styles.picker}
        >
          <Picker.Item label="Select Classroom 2" value={null} />
          {normalizedClassrooms.map((classroom, idx) => (
            <Picker.Item
              key={classroom.id}
              label={classroomNames[classroom.id] || classroom.name}
              value={idx}
            />
          ))}
        </Picker>
      </View>

      {/* Confirm Selection Button */}
      <TouchableOpacity style={styles.button} onPress={handleSelection}>
        <Text style={styles.buttonText}>Confirm Selection</Text>
      </TouchableOpacity>
    </View>
  );
};

export default SeniorFFOverlay;

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', alignItems: 'center' },
  svgOverlay: { position: 'absolute', top: 0, left: 0 },
  dropdownContainer: { flexDirection: 'row', marginVertical: 10, backgroundColor: '#f2f2f2', padding: 10 },
  picker: { height: 50, width: 180 },
  button: { marginTop: 10, backgroundColor: 'blue', padding: 10 },
  buttonText: { color: 'white', fontSize: 18, fontWeight: 'bold' },
});